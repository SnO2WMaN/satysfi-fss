@require: base/float
@import: font
@import: combination
@import: style
@import: axes
@import: context
@import: selection-cond
@import: set


module FontSelection : sig

  val find-optimal-font : font-set -> extended-context -> font-combination

  val set-debug-level : int -> unit

end = struct
  let module-name = `fss/font/selection`

  let-mutable current-debug-level <- 0
  let set-debug-level level =
    current-debug-level <- level


  let debug-font-combination level context font-comb =
    if !current-debug-level >= level
    then
      display-message (module-name ^ `: `# ^ context ^ `: `# ^ FontCombination.to-string font-comb)
    else ()

  let font-selection-score-style cond target =
    let width-score =
      if string-same cond#width target#width
      then 0.
      else 0.1
    in
    let weight-score =
      if string-same cond#weight target#weight
      then 0.
      else 0.1
    in
    let style-score =
      if string-same cond#style target#style
      then 0.
      else 1.
    in
    width-score +. weight-score +. style-score

  let font-selection-score-float coeff cond target =
    let sq-coeff = coeff *. coeff in
    let diff = (cond -. target) in
    diff *. diff /. sq-coeff

  let font-selection-score-int coeff cond target =
    font-selection-score-float coeff (float cond) (float target)

  let-rec font-selection-score cond ectx =
    let (ctx, fa) = ectx in
    match cond with
    | And cs ->
      List.map (fun cond -> font-selection-score cond ectx) cs
      |> List.fold-left (fun acc score -> acc +. score) 0.
    | Style style ->
      font-selection-score-style style fa#style
    | FloatSingle (field, value) ->
      let fa =
        match field with
        | Weight -> fa#weight
      in
      font-selection-score-float 100. value fa
    | IntSingle (field, value) ->
      let fa =
        match field with
        | Width -> fa#width
        | Slant -> fa#slant
      in
      font-selection-score-int 100. value fa

  let find-lowest score-f default-score default elems =
    let-rec sub cur-score cur elems =
      match elems with
      | [] ->
        let () = debug-font-combination 2 `find-lowest: result` cur in
        (cur-score, cur)
      | ((cond, elem)::elems) ->
        let score = score-f cond in
        let () = debug-font-combination 2 (`find-lowest: target (` ^ show-float score ^ `)`) elem in
        if Float.(cur-score < score)
        then sub cur-score cur elems
        else sub score elem elems
    in
    let () = debug-font-combination 2 (`find-lowest: default (` ^ show-float default-score ^ `)`) default in
    sub default-score default elems

  let find-optimal-font font-set ectx =
    let default-score = 1000. in
    let (score, font) =
      find-lowest
        (fun cond -> font-selection-score cond ectx)
        default-score
        font-set#default-font
        font-set#conditional-fonts
    in
    % TODO Warn when there are multiple matched fonts
    if Float.is-zero score
    then
      let () = debug-font-combination 1 `find-optimal-font: matched` font in
      font
    else
      let () = debug-font-combination 0 (`find-optimal-font: best guess of `# ^ extended-context-to-string ectx ^ #` (score=` ^ show-float score ^ `)`) font in
      font
end